name: CI/CD Backend - EC2 Privada (Spring Boot e Database)

on:
  push:
    branches:
      - main

jobs:
  build_and_deploy_backend:
    runs-on: ubuntu-latest

    steps:
      # 1. Checkout do códigO
      #Teste com secretes
      - name: Checkout do Repositório
        uses: actions/checkout@v4

      # 2. Configurar JDK 21
      - name: Configurar JDK 21
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'
          cache: 'maven'

      # 3. Executar testes (opcional - descomente se quiser)
      # - name: Executar Testes
      #   run: mvn clean test

      # 4. Gerar JAR
      - name: Gerar Artefato JAR
        run: mvn package -DskipTests=true

      # 5. Renomear JAR para nome fixo
      - name: Renomear JAR para app.jar
        run: |
          set -e
          JAR_NAME=$(ls target/*.jar | head -n 1)
          mv "$JAR_NAME" target/app.jar
          echo "JAR renomeado para: target/app.jar"
          ls -lh target/app.jar

      # 6. Copiar JAR e Script.sql para bastion (EC2 pública)
      - name: Copiar JAR e Script.sql para Bastion
        uses: easingthemes/ssh-deploy@main
        with:
          SSH_PRIVATE_KEY: ${{ secrets.EC2_SSH_KEY }}
          REMOTE_HOST: ${{ secrets.BASTION_HOST }}
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          TARGET: /home/${{ secrets.REMOTE_USER }}/backend-deploy/
          ARGS: "-rltgoDzvO"
          SOURCE: "./target/app.jar ./src/main/resources/Database/Script.sql ./src/main/resources/data.sql"

      # 7. Copiar a chave SSH para o bastion e transferir JAR para backend privado
      - name: Transferir JAR do Bastion para Backend Privado
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.BASTION_HOST }}
          username: ${{ secrets.REMOTE_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -e
            
            BACKEND_IP="${{ secrets.BACKEND_PRIVATE_IP }}"
            echo "IP do Backend: $BACKEND_IP"
            
            # Escrever chave no bastion temporariamente
            mkdir -p ~/.ssh
            echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/id_rsa
            chmod 600 ~/.ssh/id_rsa
            
            # Remover entrada antiga de known_hosts para o backend (evita WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED)
            ssh-keygen -f ~/.ssh/known_hosts -R $BACKEND_IP || true

            # Criar diretório no backend
            ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa ubuntu@$BACKEND_IP "sudo mkdir -p /usr/share/api && sudo chown ubuntu:ubuntu /usr/share/api"
            
            # Transferir JAR e scripts SQL
            scp -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa /home/${{ secrets.REMOTE_USER }}/backend-deploy/app.jar ubuntu@$BACKEND_IP:/usr/share/api/app.jar
            scp -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa /home/${{ secrets.REMOTE_USER }}/backend-deploy/Script.sql ubuntu@$BACKEND_IP:/home/ubuntu/Script.sql || echo "Script.sql não encontrado, ignorando..."
            scp -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa /home/${{ secrets.REMOTE_USER }}/backend-deploy/data.sql ubuntu@$BACKEND_IP:/home/ubuntu/data.sql || echo "data.sql não encontrado, ignorando..."
            
            # Verificar
            ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa ubuntu@$BACKEND_IP "ls -lh /usr/share/api/app.jar /home/ubuntu/*.sql"
            
            echo "JAR e scripts SQL transferidos com sucesso"

      # 8. Configurar Docker Compose e iniciar container da API na EC2 privada
      - name: Configurar e Iniciar API via Docker Compose
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.BASTION_HOST }}
          username: ${{ secrets.REMOTE_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -e
            
            BACKEND_IP="${{ secrets.BACKEND_PRIVATE_IP }}"
            
            echo "=== Configurando Docker Compose na EC2 privada ==="
            
            # Escrever chave no bastion
            mkdir -p ~/.ssh
            echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/id_rsa
            chmod 600 ~/.ssh/id_rsa
            
            # Remover entrada antiga de known_hosts para o backend (evita WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED)
            ssh-keygen -f ~/.ssh/known_hosts -R $BACKEND_IP || true

            # Criar compose-api.yaml na EC2 privada via SSH
            ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa ubuntu@$BACKEND_IP "bash -s" <<'ENDSSH'
            set -e
            
            # Criar diretório para compose
            mkdir -p /home/ubuntu/api
            
            # Criar compose-api.yaml (inclui rabbitmq + api)
            cat > /home/ubuntu/api/compose-api.yaml <<'EOF'
            version: "3.8"

            services:
              rabbitmq:
                image: rabbitmq:3-management
                container_name: rabbitmq
                environment:
                  RABBITMQ_DEFAULT_USER: ${SPRING_RABBITMQ_USERNAME:-capacita_rabbit}
                  RABBITMQ_DEFAULT_PASS: ${SPRING_RABBITMQ_PASSWORD:-CapacitaRabbit123}
                volumes:
                  - rabbitmq_data:/var/lib/rabbitmq
                ports:
                  - "5672:5672"
                  - "15672:15672"
                restart: unless-stopped
              
              mailhog:
                image: mailhog/mailhog
                container_name: mailhog
                ports:
                  - "1025:1025"  # SMTP
                  - "8025:8025"  # Painel web
                restart: unless-stopped

              api:
                image: amazoncorretto:21
                container_name: api-spring
                command: sh -c "mkdir -p /usr/share/api && java -jar /usr/share/api/app.jar"
                volumes:
                  - /usr/share/api:/usr/share/api
                ports:
                  - "8080:8080"
                environment:
                  SPRING_DATASOURCE_URL: jdbc:mysql://host.docker.internal:3306/${DATABASE_NAME:-capacita}?useSSL=false&serverTimezone=UTC&allowPublicKeyRetrieval=true
                  SPRING_DATASOURCE_USERNAME: ${DATABASE_USER:-capacita_app}
                  SPRING_DATASOURCE_PASSWORD: ${DATABASE_PASSWORD}
                  SPRING_JPA_HIBERNATE_DDL_AUTO: ${HIBERNATE_DDL_AUTO:-none}
                  SPRING_JPA_SHOW_SQL: ${SHOW_SQL:-false}
                  AWS_REGION: ${AWS_REGION:-us-east-1}
                  AWS_ACCESS_KEY_ID: ${AWS_ACCESS_KEY_ID}
                  AWS_SECRET_ACCESS_KEY: ${AWS_SECRET_ACCESS_KEY}
                  AWS_S3_BUCKET_BRONZE: ${AWS_S3_BUCKET_BRONZE}
                  AWS_S3_BUCKET_SILVER: ${AWS_S3_BUCKET_SILVER}
                  AWS_S3_BUCKET_GOLD: ${AWS_S3_BUCKET_GOLD}
                  JWT_SECRET: ${JWT_SECRET}
                  JWT_VALIDITY: ${JWT_VALIDITY:-3600000}
                  SPRING_RABBITMQ_HOST: ${SPRING_RABBITMQ_HOST:-rabbitmq}
                  SPRING_RABBITMQ_PORT: ${SPRING_RABBITMQ_PORT:-5672}
                  SPRING_RABBITMQ_USERNAME: ${SPRING_RABBITMQ_USERNAME:-capacita_rabbit}
                  SPRING_RABBITMQ_PASSWORD: ${SPRING_RABBITMQ_PASSWORD:-CapacitaRabbit123}
                  SPRING_RABBITMQ_LISTENER_SIMPLE_AUTO_STARTUP: false
                extra_hosts:
                  - "host.docker.internal:host-gateway"
                depends_on:
                  - rabbitmq
                restart: unless-stopped

            volumes:
              rabbitmq_data:
            EOF

            echo "compose-api.yaml criado"

            # Criar arquivo .env com secrets
            cat > /home/ubuntu/api/.env <<ENVEOF
            DATABASE_NAME=capacita
            DATABASE_USER=${{ secrets.DATABASE_USER }}
            DATABASE_PASSWORD=${{ secrets.DATABASE_PASSWORD }}
            HIBERNATE_DDL_AUTO=none
            SHOW_SQL=false
            AWS_REGION=us-east-1
            AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
            AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
            AWS_S3_BUCKET_BRONZE=${{ secrets.BRONZE_BUCKET }}
            AWS_S3_BUCKET_SILVER=${{ secrets.SILVER_BUCKET }}
            AWS_S3_BUCKET_GOLD=${{ secrets.GOLD_BUCKET }}
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            JWT_VALIDITY=3600000
            SPRING_RABBITMQ_HOST=rabbitmq
            SPRING_RABBITMQ_PORT=5672
            SPRING_RABBITMQ_USERNAME=${{ secrets.SPRING_RABBITMQ_USERNAME }}
            SPRING_RABBITMQ_PASSWORD=${{ secrets.SPRING_RABBITMQ_PASSWORD }}
            ENVEOF
            
            echo ".env criado com secrets"
            
            # Executar Script.sql para criar o schema do banco (antes de iniciar Spring Boot)
            echo "=== Executando Script.sql para criar schema do banco ==="
            if [ -f "/home/ubuntu/Script.sql" ]; then
                echo "Executando Script.sql..."
                sudo mysql -u ${{ secrets.DATABASE_USER }} -p'${{ secrets.DATABASE_PASSWORD }}' capacita < /home/ubuntu/Script.sql
                echo "Schema criado com sucesso"
            else
                echo "AVISO: Script.sql não encontrado. Verifique se o arquivo foi copiado corretamente."
            fi
            
            # Garantir que não exista um container solto chamado rabbitmq que conflite com o compose
            # (remove forçado caso exista; compose criará novamente)
            if sudo docker ps -a --format '{{.Names}}' | grep -q '^rabbitmq$' ; then
                echo "Removendo container rabbitmq pré-existente para evitar conflito com docker compose"
                sudo docker rm -f rabbitmq || true
            fi

            # Parar containers gerenciados pelo compose (se existirem)
            cd /home/ubuntu/api
            sudo docker compose -f compose-api.yaml down || true

            # Iniciar container da API
            echo "Iniciando container da API via Docker Compose..."
            sudo docker compose -f compose-api.yaml up -d
            
            echo "Aguardando container inicializar..."
            sleep 10
            
            # Verificar status
            echo "Status do container:"
            sudo docker ps -a | grep api-spring || true
            
            # Verificar logs
            echo "Logs do container (últimas 50 linhas):"
            sudo docker logs api-spring --tail 50 || true
            
            # Verificar se a aplicação está respondendo
            echo "Verificando se a aplicação está respondendo na porta 8080..."
            sleep 5
            curl -f http://localhost:8080/actuator/health || curl -f http://localhost:8080/ || echo "Aplicação ainda não está respondendo (pode levar alguns segundos)"
            
            # Executar data.sql para popular o banco (após Spring Boot iniciar)
            echo "=== Executando data.sql para popular banco de dados ==="
            if [ -f "/home/ubuntu/data.sql" ]; then
                echo "Aguardando Spring Boot inicializar completamente..."
                sleep 10
                echo "Executando data.sql..."
                sudo mysql -u ${{ secrets.DATABASE_USER }} -p'${{ secrets.DATABASE_PASSWORD }}' capacita < /home/ubuntu/data.sql
                echo "Banco de dados populado com sucesso"
            else
                echo "AVISO: data.sql não encontrado. Banco ficará vazio."
            fi
            
            ENDSSH
            
            # Limpar chave
            rm -f ~/.ssh/id_rsa
            
            echo "=== Deploy do backend via Docker concluído ==="
            echo "Backend está rodando em: $BACKEND_IP:8080"
            echo "Acessível via frontend público através do proxy NGINX"      # 9. Verificar conectividade do frontend ao backend
      - name: Testar Conectividade Frontend -> Backend
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.BASTION_HOST }}
          username: ${{ secrets.REMOTE_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -e
            
            BACKEND_IP="${{ secrets.BACKEND_PRIVATE_IP }}"
            
            echo "=== Testando conectividade da EC2 pública ao backend privado ==="
            
            # Testar se consegue alcançar o backend da EC2 pública
            curl -f http://$BACKEND_IP:8080/actuator/health && echo "Backend acessível!" || echo "Backend não acessível ainda"

            echo "=== Teste concluído ==="
            echo "Se o backend não estiver acessível, aguarde alguns segundos e tente novamente manualmente"
