name: CI/CD Backend - EC2 Privada (Spring Boot)

on:
  push:
    branches:
      - main

jobs:
  build_and_deploy_backend:
    runs-on: ubuntu-latest

    steps:
      # 1. Checkout do código
      - name: Checkout do Repositório
        uses: actions/checkout@v4

      # 2. Configurar JDK 21
      - name: Configurar JDK 21
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'
          cache: 'maven'

      # 3. Executar testes (opcional - descomente se quiser)
      # - name: Executar Testes
      #   run: mvn clean test

      # 4. Gerar JAR
      - name: Gerar Artefato JAR
        run: mvn package -DskipTests=true

      # 5. Renomear JAR para nome fixo
      - name: Renomear JAR para app.jar
        run: |
          set -e
          JAR_NAME=$(ls target/*.jar | head -n 1)
          mv "$JAR_NAME" target/app.jar
          echo "JAR renomeado para: target/app.jar"
          ls -lh target/app.jar

      # 6. Copiar JAR para EC2 pública (bastion) primeiro
      - name: Copiar JAR para EC2 Pública (Bastion)
        uses: easingthemes/ssh-deploy@main
        with:
          SSH_PRIVATE_KEY: ${{ secrets.EC2_SSH_KEY }}
          REMOTE_HOST: ${{ secrets.BASTION_HOST }}
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          TARGET: /home/${{ secrets.REMOTE_USER }}/backend-deploy/
          ARGS: "-rltgoDzvO"
          SOURCE: "./target/app.jar"

      # 7. Transferir JAR da EC2 pública para EC2 privada do backend
      - name: Transferir JAR para EC2 Privada (Backend)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.BASTION_HOST }}
          username: ${{ secrets.REMOTE_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -e
            
            echo "=== Transferindo JAR da EC2 pública para EC2 privada do backend ==="
            
            # IP privado do backend (conforme terraform outputs)
            BACKEND_IP="${{ secrets.BACKEND_PRIVATE_IP }}"
            
            echo "IP do Backend: $BACKEND_IP"
            
            # Criar diretório de destino na EC2 privada
            ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa ubuntu@$BACKEND_IP "sudo mkdir -p /opt/app && sudo chown ubuntu:ubuntu /opt/app"
            
            # Copiar JAR para EC2 privada
            echo "Copiando JAR para EC2 privada..."
            scp -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa /home/${{ secrets.REMOTE_USER }}/backend-deploy/app.jar ubuntu@$BACKEND_IP:/opt/app/app.jar
            
            echo "JAR copiado com sucesso para $BACKEND_IP:/opt/app/app.jar"
            
            # Verificar se o JAR foi copiado
            ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa ubuntu@$BACKEND_IP "ls -lh /opt/app/app.jar"

      # 8. Configurar e reiniciar serviço Spring Boot na EC2 privada
      - name: Configurar e Reiniciar Spring Boot na EC2 Privada
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.BASTION_HOST }}
          username: ${{ secrets.REMOTE_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -e
            
            BACKEND_IP="${{ secrets.BACKEND_PRIVATE_IP }}"
            
            echo "=== Configurando Spring Boot na EC2 privada ==="
            
            # Criar/atualizar application.properties na EC2 privada
            ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa ubuntu@$BACKEND_IP <<'ENDSSH'
            set -e
            
            # Criar application.properties
            cat > /opt/app/application.properties <<'EOF'
            # Application name
            spring.application.name=crud-gratitude-servicos
            
            # Server
            server.port=8080
            
            # Database MySQL (local na EC2 privada)
            spring.datasource.url=jdbc:mysql://localhost:3306/capacita?useSSL=false&serverTimezone=UTC&allowPublicKeyRetrieval=true
            spring.datasource.username=root
            spring.datasource.password=${{ secrets.MYSQL_ROOT_PASSWORD }}
            spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
            
            # JPA / Hibernate
            spring.jpa.hibernate.ddl-auto=update
            spring.jpa.show-sql=false
            spring.jpa.defer-datasource-initialization=true
            spring.sql.init.mode=never
            
            # AWS S3 (configurar conforme seus buckets)
            aws.s3.region=us-east-1
            aws.s3.bucket.bronze=${{ secrets.BRONZE_BUCKET }}
            aws.s3.bucket.silver=${{ secrets.SILVER_BUCKET }}
            aws.s3.bucket.gold=${{ secrets.GOLD_BUCKET }}
            
            # JWT
            jwt.validity=3600000
            jwt.secret=${{ secrets.JWT_SECRET }}
            EOF
            
            echo "application.properties criado/atualizado"
            
            # Verificar se o serviço systemd existe, senão criar
            if [ ! -f /etc/systemd/system/spring-app.service ]; then
                echo "Criando serviço systemd..."
                
                sudo tee /etc/systemd/system/spring-app.service > /dev/null <<'SERVICEEOF'
            [Unit]
            Description=Spring Boot Gratitude App
            After=mysql.service
            
            [Service]
            User=ubuntu
            WorkingDirectory=/opt/app
            Environment="JAVA_HOME=/opt/jdk-21"
            Environment="PATH=/opt/jdk-21/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
            ExecStart=/opt/jdk-21/bin/java -jar /opt/app/app.jar --spring.config.location=file:/opt/app/application.properties
            Restart=always
            RestartSec=10
            
            [Install]
            WantedBy=multi-user.target
            SERVICEEOF
                
                sudo systemctl daemon-reload
                sudo systemctl enable spring-app.service
                
                echo "Serviço systemd criado e habilitado"
            fi
            
            # Reiniciar serviço
            echo "Reiniciando serviço Spring Boot..."
            sudo systemctl restart spring-app.service
            
            echo "Aguardando serviço inicializar..."
            sleep 10
            
            # Verificar status
            echo "Status do serviço:"
            sudo systemctl status spring-app.service --no-pager || true
            
            # Verificar logs
            echo "Logs do serviço (últimas 50 linhas):"
            sudo journalctl -u spring-app.service -n 50 --no-pager
            
            # Verificar se a aplicação está respondendo
            echo "Verificando se a aplicação está respondendo na porta 8080..."
            sleep 5
            curl -f http://localhost:8080/actuator/health || curl -f http://localhost:8080/ || echo "Aplicação ainda não está respondendo (pode levar alguns segundos)"
            
            ENDSSH
            
            echo "=== Deploy do backend concluído ==="
            echo "Backend está rodando em: $BACKEND_IP:8080"
            echo "Acessível via frontend público através do proxy NGINX"

      # 9. Verificar conectividade do frontend ao backend
      - name: Testar Conectividade Frontend -> Backend
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.BASTION_HOST }}
          username: ${{ secrets.REMOTE_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -e
            
            BACKEND_IP="${{ secrets.BACKEND_PRIVATE_IP }}"
            
            echo "=== Testando conectividade da EC2 pública ao backend privado ==="
            
            # Testar se consegue alcançar o backend da EC2 pública
            curl -f http://$BACKEND_IP:8080/actuator/health && echo "Backend acessível!" || echo "Backend não acessível ainda"

            echo "=== Teste concluído ==="
            echo "Se o backend não estiver acessível, aguarde alguns segundos e tente novamente manualmente"
